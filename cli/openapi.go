// Code generated by openapi-cli-generator. DO NOT EDIT.
// See https://github.com/danielgtaylor/openapi-cli-generator

package main

import (
	"strings"

	"github.com/danielgtaylor/openapi-cli-generator/cli"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"gopkg.in/h2non/gentleman.v2"
)

var openapiSubcommand bool

func openapiServers() []map[string]string {
	return []map[string]string{

		map[string]string{
			"description": "Development test server (uses test data)",
			"url":         "https://sciapps.colorado.edu/onestop-search",
		},

		map[string]string{
			"description": "NOAA OneStop",
			"url":         "https://data.noaa.gov/onestop/api/search",
		},
	}
}

// OpenapiGetCollection Get Collection Info
func OpenapiGetCollection(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getcollection"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/collection"

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// OpenapiHeadCollection Get Collection Info
func OpenapiHeadCollection(params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "headcollection"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/collection"

	req := cli.Client.Head().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiGetCollectionById Collection by ID
func OpenapiGetCollectionById(paramId string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getcollectionbyid"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/collection/{id}"
	url = strings.Replace(url, "{id}", paramId, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// OpenapiHeadCollectionById Collection by ID
func OpenapiHeadCollectionById(paramId string, params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "headcollectionbyid"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/collection/{id}"
	url = strings.Replace(url, "{id}", paramId, 1)

	req := cli.Client.Head().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiGetFlattenedGranule Get Flattened Granule Info
func OpenapiGetFlattenedGranule(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getflattenedgranule"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/flattened-granule"

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// OpenapiHeadFlattenedGranule Get Flattened Granule Info
func OpenapiHeadFlattenedGranule(params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "headflattenedgranule"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/flattened-granule"

	req := cli.Client.Head().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiGetFlattenedGranuleById Flattened Granule by ID
func OpenapiGetFlattenedGranuleById(paramId string, params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "getflattenedgranulebyid"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/flattened-granule/{id}"
	url = strings.Replace(url, "{id}", paramId, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiHeadFlattenedGranuleById Flattened Granule by ID
func OpenapiHeadFlattenedGranuleById(paramId string, params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "headflattenedgranulebyid"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/flattened-granule/{id}"
	url = strings.Replace(url, "{id}", paramId, 1)

	req := cli.Client.Head().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiGetGranule Get Granule Info
func OpenapiGetGranule(params *viper.Viper) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "getgranule"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/granule"

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// OpenapiHeadGranule Get Granule Info
func OpenapiHeadGranule(params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "headgranule"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/granule"

	req := cli.Client.Head().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiGetGranuleById Granule by ID
func OpenapiGetGranuleById(paramId string, params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "getgranulebyid"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/granule/{id}"
	url = strings.Replace(url, "{id}", paramId, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiHeadGranuleById Granule by ID
func OpenapiHeadGranuleById(paramId string, params *viper.Viper) (*gentleman.Response, interface{}, error) {
	handlerPath := "headgranulebyid"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/granule/{id}"
	url = strings.Replace(url, "{id}", paramId, 1)

	req := cli.Client.Head().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, nil
}

// OpenapiSearchCollection Retrieve collection metadata
func OpenapiSearchCollection(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "searchcollection"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/search/collection"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// OpenapiSearchFlattenedGranule Retrieve flattened granule metadata
func OpenapiSearchFlattenedGranule(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "searchflattenedgranule"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/search/flattened-granule"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

// OpenapiSearchGranule Retrieve granule metadata
func OpenapiSearchGranule(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, error) {
	handlerPath := "searchgranule"
	if openapiSubcommand {
		handlerPath = "openapi " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = openapiServers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/search/granule"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, nil
}

func openapiRegister(subcommand bool) {
	root := cli.Root

	if subcommand {
		root = &cobra.Command{
			Use:   "openapi",
			Short: "OneStop Search API",
			Long:  cli.Markdown("Search Collections and Granules! More information on search request and responses available at [Search API Requests](https://github.com/cedardevs/onestop/wiki/OneStop-Search-API-Requests) and [Search API Responses](https://github.com/cedardevs/onestop/wiki/OneStop-Search-API-Responses)."),
		}
		openapiSubcommand = true
	} else {
		cli.Root.Short = "OneStop Search API"
		cli.Root.Long = cli.Markdown("Search Collections and Granules! More information on search request and responses available at [Search API Requests](https://github.com/cedardevs/onestop/wiki/OneStop-Search-API-Requests) and [Search API Responses](https://github.com/cedardevs/onestop/wiki/OneStop-Search-API-Responses).")
	}

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getcollection",
			Short:   "Get Collection Info",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiGetCollection(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "headcollection",
			Short:   "Get Collection Info",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiHeadCollection(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getcollectionbyid id",
			Short:   "Collection by ID",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiGetCollectionById(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "headcollectionbyid id",
			Short:   "Collection by ID",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiHeadCollectionById(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getflattenedgranule",
			Short:   "Get Flattened Granule Info",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiGetFlattenedGranule(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "headflattenedgranule",
			Short:   "Get Flattened Granule Info",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiHeadFlattenedGranule(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getflattenedgranulebyid id",
			Short:   "Flattened Granule by ID",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiGetFlattenedGranuleById(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "headflattenedgranulebyid id",
			Short:   "Flattened Granule by ID",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiHeadFlattenedGranuleById(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getgranule",
			Short:   "Get Granule Info",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiGetGranule(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "headgranule",
			Short:   "Get Granule Info",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiHeadGranule(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "getgranulebyid id",
			Short:   "Granule by ID",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiGetGranuleById(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "headgranulebyid id",
			Short:   "Granule by ID",
			Long:    cli.Markdown(""),
			Example: examples,
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, err := OpenapiHeadGranuleById(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		examples += "  " + cli.Root.CommandPath() + " searchcollection facets: true, filters[]{name: science, type: facet, values: Agriculture}, []{name: instruments, type: facet, values: ADCP > Acoustic Doppler Current Profiler}, page{max: 20, offset: 0}, queries[]{type: queryText, value: weather}\n"

		cmd := &cobra.Command{
			Use:     "searchcollection",
			Short:   "Retrieve collection metadata",
			Long:    cli.Markdown("Retrieve collection metadata records matching the text query string, spatial, and/or temporal filter.\n## Request Schema (application/json)\n\nadditionalProperties: false\ndescription: The shape of a search request body that can be sent to the OneStop API\n  to execute a search against available metadata. Collections are returned by default\n  unless a collection filter is included, resulting in granules being returned.\nproperties:\n  facets:\n    default: false\n    description: Flag to request counts of results by GCMD keywords in addition to\n      results.\n    type: boolean\n  filters:\n    items:\n      oneOf:\n      - additionalProperties: false\n        description: Filter results by before, after, or a date range.\n        properties:\n          after:\n            description: Beginning of the date range, e.g., look for all results *after*\n              this date.\n            format: date-time\n            type: string\n          before:\n            description: End of the date range, e.g., look for all results *before*\n              this date.\n            format: date-time\n            type: string\n          relation:\n            default: intersects\n            description: How the result time range relates to the query time range,\n              e.g., return all datasets whose time range is within the given time\n              range.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - datetime\n        required:\n        - type\n        title: Datetime Filter\n        type: object\n      - additionalProperties: false\n        description: Filter results by before, after, or a date range. Differs from\n          the Datetime Filter in that it handles year values only.\n        properties:\n          after:\n            description: Beginning of the date range, e.g., look for all results *after*\n              this year.\n            multipleOf: 1\n            type: number\n          before:\n            description: End of the date range, e.g., look for all results *before*\n              this year.\n            multipleOf: 1\n            type: number\n          relation:\n            default: intersects\n            description: How the result time range relates to the query time range,\n              e.g., return all datasets whose time range is within the given time\n              range.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - year\n        required:\n        - type\n        title: Year Filter\n        type: object\n      - additionalProperties: false\n        description: Filters results based on given terms (data formats, link protocols,\n          service link protocols, GCMD keywords) where returned results MUST have\n          the specified term values. Multiple facetFilter objects will be combined\n          with logical AND; multiple values in a single facetFilter object will be\n          combined with the logical OR.\n        properties:\n          name:\n            description: 'One of the following: ''dataFormats'', ''linkProtocols'',\n              ''serviceLinkProtocols'', or GCMD keyword categories (''science'', ''services'',\n              ''locations'', ''instruments'', ''platforms'', ''projects'', ''dataCenters'',\n              ''horizontalResolution'', ''verticalResolution'', ''temporalResolution'').'\n            enum:\n            - dataFormats\n            - linkProtocols\n            - serviceLinkProtocols\n            - science\n            - services\n            - locations\n            - instruments\n            - platforms\n            - projects\n            - dataCenters\n            - horizontalResolution\n            - verticalResolution\n            - temporalResolution\n          type:\n            description: Filter type.\n            enum:\n            - facet\n          values:\n            description: List of terms to match\n            items:\n              description: Exact match data format(s) (e.g. - \"NETCDF\"), link or service\n                link protocol(s) (e.g. - \"ftp\"), or GCMD keyword(s) (e.g. - \"Atmosphere\n                > Atmospheric Temperature > Surface Temperature\")\n              type: string\n            type: array\n        required:\n        - type\n        - name\n        - values\n        title: Facet Filter\n        type: object\n      - additionalProperties: false\n        description: Filter that returns results whose bounding geometry contains\n          the specified geographical coordinate.\n        properties:\n          geometry:\n            $ref: '#/components/schemas/geometry'\n          relation:\n            default: intersects\n            description: How the result geometry relates to the query geometry, e.g.,\n              return all datasets whose geometry contains the given point.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - geometry\n        required:\n        - type\n        - geometry\n        title: Geometry Filter\n        type: object\n      - additionalProperties: false\n        description: Filter granules by specific collection(s). If multiple collection\n          filters are used, or multiple values in a single collection filter, then\n          the search is performed with a logical OR.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - collection\n          values:\n            description: List of collection UUIDs.\n            items:\n              description: Collection UUID\n              type: string\n            type: array\n        required:\n        - type\n        - values\n        title: Collection Filter\n        type: object\n      - additionalProperties: false\n        description: Flag to request that geospatially global results be excluded.\n          Defaults to false if not provided.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - excludeGlobal\n          value:\n            default: false\n            type: boolean\n        required:\n        - type\n        - value\n        title: Exclude Global Filter\n        type: object\n    type: array\n  page:\n    additionalProperties: false\n    description: Pagination of results\n    properties:\n      max:\n        default: 10\n        description: Maximum number of results returned.\n        maximum: 1000\n        minimum: 0\n        type: integer\n      offset:\n        default: 0\n        description: Number of records by which to offset results.\n        type: integer\n    required:\n    - max\n    - offset\n    title: Pagination\n    type: object\n  queries:\n    items:\n      oneOf:\n      - additionalProperties: false\n        description: When providing multiple queryText objects in your search request,\n          keep in mind that they will be combined with a logical AND. Terms use Lucene\n          Query Syntax.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - queryText\n          value:\n            description: Text query to search with that is valid so long as it does\n              not have a leading wildcard ('*' or '?')\n            type: string\n        required:\n        - type\n        - value\n        title: Text Query\n        type: object\n    type: array\n  summary:\n    default: true\n    description: Flag to request summary of search results instead of full set of\n      attributes.\n    type: boolean\ntitle: Search Request\ntype: object\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := OpenapiSearchCollection(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "searchflattenedgranule",
			Short:   "Retrieve flattened granule metadata",
			Long:    cli.Markdown("Retrieve flattened granule metadata records matching the text query string, spatial, and/or temporal filter.\n## Request Schema (application/json)\n\nadditionalProperties: false\ndescription: The shape of a search request body that can be sent to the OneStop API\n  to execute a search against available metadata. Collections are returned by default\n  unless a collection filter is included, resulting in granules being returned.\nproperties:\n  facets:\n    default: false\n    description: Flag to request counts of results by GCMD keywords in addition to\n      results.\n    type: boolean\n  filters:\n    items:\n      oneOf:\n      - additionalProperties: false\n        description: Filter results by before, after, or a date range.\n        properties:\n          after:\n            description: Beginning of the date range, e.g., look for all results *after*\n              this date.\n            format: date-time\n            type: string\n          before:\n            description: End of the date range, e.g., look for all results *before*\n              this date.\n            format: date-time\n            type: string\n          relation:\n            default: intersects\n            description: How the result time range relates to the query time range,\n              e.g., return all datasets whose time range is within the given time\n              range.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - datetime\n        required:\n        - type\n        title: Datetime Filter\n        type: object\n      - additionalProperties: false\n        description: Filter results by before, after, or a date range. Differs from\n          the Datetime Filter in that it handles year values only.\n        properties:\n          after:\n            description: Beginning of the date range, e.g., look for all results *after*\n              this year.\n            multipleOf: 1\n            type: number\n          before:\n            description: End of the date range, e.g., look for all results *before*\n              this year.\n            multipleOf: 1\n            type: number\n          relation:\n            default: intersects\n            description: How the result time range relates to the query time range,\n              e.g., return all datasets whose time range is within the given time\n              range.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - year\n        required:\n        - type\n        title: Year Filter\n        type: object\n      - additionalProperties: false\n        description: Filters results based on given terms (data formats, link protocols,\n          service link protocols, GCMD keywords) where returned results MUST have\n          the specified term values. Multiple facetFilter objects will be combined\n          with logical AND; multiple values in a single facetFilter object will be\n          combined with the logical OR.\n        properties:\n          name:\n            description: 'One of the following: ''dataFormats'', ''linkProtocols'',\n              ''serviceLinkProtocols'', or GCMD keyword categories (''science'', ''services'',\n              ''locations'', ''instruments'', ''platforms'', ''projects'', ''dataCenters'',\n              ''horizontalResolution'', ''verticalResolution'', ''temporalResolution'').'\n            enum:\n            - dataFormats\n            - linkProtocols\n            - serviceLinkProtocols\n            - science\n            - services\n            - locations\n            - instruments\n            - platforms\n            - projects\n            - dataCenters\n            - horizontalResolution\n            - verticalResolution\n            - temporalResolution\n          type:\n            description: Filter type.\n            enum:\n            - facet\n          values:\n            description: List of terms to match\n            items:\n              description: Exact match data format(s) (e.g. - \"NETCDF\"), link or service\n                link protocol(s) (e.g. - \"ftp\"), or GCMD keyword(s) (e.g. - \"Atmosphere\n                > Atmospheric Temperature > Surface Temperature\")\n              type: string\n            type: array\n        required:\n        - type\n        - name\n        - values\n        title: Facet Filter\n        type: object\n      - additionalProperties: false\n        description: Filter that returns results whose bounding geometry contains\n          the specified geographical coordinate.\n        properties:\n          geometry:\n            $ref: '#/components/schemas/geometry'\n          relation:\n            default: intersects\n            description: How the result geometry relates to the query geometry, e.g.,\n              return all datasets whose geometry contains the given point.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - geometry\n        required:\n        - type\n        - geometry\n        title: Geometry Filter\n        type: object\n      - additionalProperties: false\n        description: Filter granules by specific collection(s). If multiple collection\n          filters are used, or multiple values in a single collection filter, then\n          the search is performed with a logical OR.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - collection\n          values:\n            description: List of collection UUIDs.\n            items:\n              description: Collection UUID\n              type: string\n            type: array\n        required:\n        - type\n        - values\n        title: Collection Filter\n        type: object\n      - additionalProperties: false\n        description: Flag to request that geospatially global results be excluded.\n          Defaults to false if not provided.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - excludeGlobal\n          value:\n            default: false\n            type: boolean\n        required:\n        - type\n        - value\n        title: Exclude Global Filter\n        type: object\n    type: array\n  page:\n    additionalProperties: false\n    description: Pagination of results\n    properties:\n      max:\n        default: 10\n        description: Maximum number of results returned.\n        maximum: 1000\n        minimum: 0\n        type: integer\n      offset:\n        default: 0\n        description: Number of records by which to offset results.\n        type: integer\n    required:\n    - max\n    - offset\n    title: Pagination\n    type: object\n  queries:\n    items:\n      oneOf:\n      - additionalProperties: false\n        description: When providing multiple queryText objects in your search request,\n          keep in mind that they will be combined with a logical AND. Terms use Lucene\n          Query Syntax.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - queryText\n          value:\n            description: Text query to search with that is valid so long as it does\n              not have a leading wildcard ('*' or '?')\n            type: string\n        required:\n        - type\n        - value\n        title: Text Query\n        type: object\n    type: array\n  summary:\n    default: true\n    description: Flag to request summary of search results instead of full set of\n      attributes.\n    type: boolean\ntitle: Search Request\ntype: object\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := OpenapiSearchFlattenedGranule(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "searchgranule",
			Short:   "Retrieve granule metadata",
			Long:    cli.Markdown("Retrieve granule metadata records matching the text query string, spatial, and/or temporal filter.\n## Request Schema (application/json)\n\nadditionalProperties: false\ndescription: The shape of a search request body that can be sent to the OneStop API\n  to execute a search against available metadata. Collections are returned by default\n  unless a collection filter is included, resulting in granules being returned.\nproperties:\n  facets:\n    default: false\n    description: Flag to request counts of results by GCMD keywords in addition to\n      results.\n    type: boolean\n  filters:\n    items:\n      oneOf:\n      - additionalProperties: false\n        description: Filter results by before, after, or a date range.\n        properties:\n          after:\n            description: Beginning of the date range, e.g., look for all results *after*\n              this date.\n            format: date-time\n            type: string\n          before:\n            description: End of the date range, e.g., look for all results *before*\n              this date.\n            format: date-time\n            type: string\n          relation:\n            default: intersects\n            description: How the result time range relates to the query time range,\n              e.g., return all datasets whose time range is within the given time\n              range.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - datetime\n        required:\n        - type\n        title: Datetime Filter\n        type: object\n      - additionalProperties: false\n        description: Filter results by before, after, or a date range. Differs from\n          the Datetime Filter in that it handles year values only.\n        properties:\n          after:\n            description: Beginning of the date range, e.g., look for all results *after*\n              this year.\n            multipleOf: 1\n            type: number\n          before:\n            description: End of the date range, e.g., look for all results *before*\n              this year.\n            multipleOf: 1\n            type: number\n          relation:\n            default: intersects\n            description: How the result time range relates to the query time range,\n              e.g., return all datasets whose time range is within the given time\n              range.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - year\n        required:\n        - type\n        title: Year Filter\n        type: object\n      - additionalProperties: false\n        description: Filters results based on given terms (data formats, link protocols,\n          service link protocols, GCMD keywords) where returned results MUST have\n          the specified term values. Multiple facetFilter objects will be combined\n          with logical AND; multiple values in a single facetFilter object will be\n          combined with the logical OR.\n        properties:\n          name:\n            description: 'One of the following: ''dataFormats'', ''linkProtocols'',\n              ''serviceLinkProtocols'', or GCMD keyword categories (''science'', ''services'',\n              ''locations'', ''instruments'', ''platforms'', ''projects'', ''dataCenters'',\n              ''horizontalResolution'', ''verticalResolution'', ''temporalResolution'').'\n            enum:\n            - dataFormats\n            - linkProtocols\n            - serviceLinkProtocols\n            - science\n            - services\n            - locations\n            - instruments\n            - platforms\n            - projects\n            - dataCenters\n            - horizontalResolution\n            - verticalResolution\n            - temporalResolution\n          type:\n            description: Filter type.\n            enum:\n            - facet\n          values:\n            description: List of terms to match\n            items:\n              description: Exact match data format(s) (e.g. - \"NETCDF\"), link or service\n                link protocol(s) (e.g. - \"ftp\"), or GCMD keyword(s) (e.g. - \"Atmosphere\n                > Atmospheric Temperature > Surface Temperature\")\n              type: string\n            type: array\n        required:\n        - type\n        - name\n        - values\n        title: Facet Filter\n        type: object\n      - additionalProperties: false\n        description: Filter that returns results whose bounding geometry contains\n          the specified geographical coordinate.\n        properties:\n          geometry:\n            $ref: '#/components/schemas/geometry'\n          relation:\n            default: intersects\n            description: How the result geometry relates to the query geometry, e.g.,\n              return all datasets whose geometry contains the given point.\n            enum:\n            - contains\n            - disjoint\n            - intersects\n            - within\n          type:\n            description: Filter type.\n            enum:\n            - geometry\n        required:\n        - type\n        - geometry\n        title: Geometry Filter\n        type: object\n      - additionalProperties: false\n        description: Filter granules by specific collection(s). If multiple collection\n          filters are used, or multiple values in a single collection filter, then\n          the search is performed with a logical OR.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - collection\n          values:\n            description: List of collection UUIDs.\n            items:\n              description: Collection UUID\n              type: string\n            type: array\n        required:\n        - type\n        - values\n        title: Collection Filter\n        type: object\n      - additionalProperties: false\n        description: Flag to request that geospatially global results be excluded.\n          Defaults to false if not provided.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - excludeGlobal\n          value:\n            default: false\n            type: boolean\n        required:\n        - type\n        - value\n        title: Exclude Global Filter\n        type: object\n    type: array\n  page:\n    additionalProperties: false\n    description: Pagination of results\n    properties:\n      max:\n        default: 10\n        description: Maximum number of results returned.\n        maximum: 1000\n        minimum: 0\n        type: integer\n      offset:\n        default: 0\n        description: Number of records by which to offset results.\n        type: integer\n    required:\n    - max\n    - offset\n    title: Pagination\n    type: object\n  queries:\n    items:\n      oneOf:\n      - additionalProperties: false\n        description: When providing multiple queryText objects in your search request,\n          keep in mind that they will be combined with a logical AND. Terms use Lucene\n          Query Syntax.\n        properties:\n          type:\n            description: Filter type.\n            enum:\n            - queryText\n          value:\n            description: Text query to search with that is valid so long as it does\n              not have a leading wildcard ('*' or '?')\n            type: string\n        required:\n        - type\n        - value\n        title: Text Query\n        type: object\n    type: array\n  summary:\n    default: true\n    description: Flag to request summary of search results instead of full set of\n      attributes.\n    type: boolean\ntitle: Search Request\ntype: object\n"),
			Example: examples,
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, err := OpenapiSearchGranule(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

}
