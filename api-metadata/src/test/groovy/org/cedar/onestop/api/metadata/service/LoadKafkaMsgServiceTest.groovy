package org.cedar.onestop.api.metadata.serviceimport groovy.json.JsonSlurperimport spock.lang.Specificationimport spock.lang.Unroll@Unrollclass LoadKafkaMsgServiceTest extends Specification {  def mockElasticsearchService = Mock(ElasticsearchService)  def metadataManagementService = new MetadataManagementService(mockElasticsearchService)    def setup() {    metadataManagementService.PREFIX = 'prefix-'    metadataManagementService.COLLECTION_SEARCH_INDEX = 'search_collection'    metadataManagementService.COLLECTION_STAGING_INDEX = 'staging_collection'    metadataManagementService.GRANULE_SEARCH_INDEX = 'search_granule'    metadataManagementService.GRANULE_STAGING_INDEX = 'staging_granule'    metadataManagementService.FLAT_GRANULE_SEARCH_INDEX = 'search_flattened_granule'  }    def "Load valid metadata to a staging index" () {    given:    def inputMsg = ClassLoader.systemClassLoader.getResourceAsStream('parsed-iso.json').text    def inputMap = new JsonSlurper().parseText(inputMsg as String) as Map    def analysisMsg = ClassLoader.systemClassLoader.getResourceAsStream('parsed-analysis.json').text    def analysisMap = new JsonSlurper().parseText(analysisMsg) as Map    Map parsedMap = [id: '123', discovery: inputMap, analysis: analysisMap]    List<Map> parsedMapList = [parsedMap]       when:    parsedMap instanceof Map    def msgMap = metadataManagementService.loadParsedMetadata(parsedMapList)    Map expectedMap = inputMap as Map    then:    msgMap.data.id == ['123']    msgMap.data.type == ['collection']    msgMap.data.attributes.fileIdentifier == [expectedMap.fileIdentifier]  }}