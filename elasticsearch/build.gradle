buildscript {
  dependencies {
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7'
  }
}


import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import groovyx.net.http.HTTPBuilder
import groovyx.net.http.ContentType
import com.wiredforcode.gradle.spawn.SpawnProcessTask
import com.wiredforcode.gradle.spawn.KillProcessTask
import groovyx.net.http.Method
import ncei.onestop.api.service.MetadataParser

plugins {
  id "com.wiredforcode.spawn" version "0.6.0"
}

def esVersion = '2.3.2'

task installElasticSearch(type: DownloadTask) {
  url = "https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/${esVersion}/elasticsearch-${esVersion}.tar.gz"
  targetDir = "${buildDir}/elasticsearch"

  finalizedBy 'extractElasticSearch'
}

task extractElasticSearch(type: Copy) {
  from tarTree(installElasticSearch.targetFile)
  into installElasticSearch.targetFile.parentFile
}

task start(type: SpawnProcessTask) {
  dependsOn 'installElasticSearch'
  onlyIf { !(new File(projectDir, '.pid.lock').exists()) }

  directory projectDir.absolutePath
  command "${buildDir}/elasticsearch/elasticsearch-${esVersion}/bin/elasticsearch"
  ready 'started'
}

task stop(type: KillProcessTask) {
  onlyIf { new File(projectDir, '.pid.lock').exists() }
  directory projectDir.absolutePath
}

task bootstrapGHRSST {
  dependsOn 'start', 'initializeIndex', ':api:start'
  doLast {
    def srcURL = new URL('http://data.nodc.noaa.gov/geoportal/rest/find/document' +
            '?searchText=title:GHRSST%20NOT%20title:Documentation&start=1&max=100&f=json')
    def load = new HTTPBuilder('http://localhost:8097/api/load')

    def json = new JsonSlurper().parse(srcURL)
    json.records.each { record ->
      record.links.each { link ->
        if (link.type.contains("metadata")) {
          load.request(Method.POST) {
            requestContentType = 'application/xml'
            body = new URL(link.href).text
            response.success = { resp, data ->
              println "${data.data.id} created: ${data.data.attributes.created}"
            }
            response.failure = { resp, data ->
              println "Error uploading metadata from ${link.href}: ${data.errors.detail}"
            }
          }
        }
      }
    }
  }
}

task bootstrapDEM {
  dependsOn 'start', 'initializeIndex', ':api:start'
  doLast {
    def srcUrl = "https://www.ngdc.noaa.gov/metadata/published/NOAA/NESDIS/NGDC/MGG/DEM/iso/xml"
    def http = new HTTPBuilder(srcUrl)
    def load = new HTTPBuilder('http://localhost:8097/api/load')

    def html = http.get([:])
    html."**".findAll { record ->
      def link = (srcUrl.toString() + '/' + record.toString())
      if (link.endsWith(".xml")) {
        load.request(Method.POST) {
          requestContentType = 'application/xml'
          body = new URL(link).text
          response.success = { resp, data ->
            println "${data.data.id} created: ${data.data.attributes.created}"
          }
          response.failure = { resp, data ->
            println "Error uploading metadata from ${link}: ${data.errors.title}, ${data.errors.detail}"
          }
        }
      }
    }
  }
}

task bootstrapCOOPS {
  dependsOn 'start', 'initializeIndex', ':api:start'
  doLast {
    def load = new HTTPBuilder('http://localhost:8097/api/load')
    def debug = 1

    1.step(10000, 1000) { i ->
      def url = "http://www.nodc.noaa.gov/search/granule/rest/find/document?" +
              "searchText=fileIdentifier%3ACO-OPS*&orderBy=title&start=${i}&max=${i+1000}&after=2016-06-30&f=json"

    def srcURL = new URL(url)
      def json = new JsonSlurper().parse(srcURL)
      json.records.each { record ->
        record.links.each { link ->
          if (link.type.contains("metadata")) {
            debug++
            load.request(Method.POST) {
              requestContentType = 'application/xml'
              body = new URL(link.href).text
              response.success = { resp, data ->
                println "${data.data.id} created #${debug}: ${data.data.attributes.created}"
              }
              response.failure = { resp, data ->
                println "Error uploading metadata #${debug} from ${link.href}: ${data.errors.detail}"
              }
            }
          }
        }
      }
    }
  }
}

task initializeIndex {
  dependsOn 'start'
  doLast {
    def indexExists = true
    def esIndex = new HTTPBuilder('http://localhost:9200/onestop_v1') // TODO need to have different name from GP index
    esIndex.request(Method.HEAD) {
      response.success = {
        println "Index mapping already in place, ready to load data"
      }
      response.failure = {
        println "Index needs to be created... "
        indexExists = false
      }
    }

    if (!indexExists) {
      esIndex.request(Method.PUT, ContentType.JSON) { req ->
        body = file('../api/src/integrationTest/resources/config/index-settings.json').text
      }

      def mapping = new HTTPBuilder('http://localhost:9200/onestop_v1/_mapping/metadata')
      mapping.request(Method.PUT, ContentType.JSON) {
        body = file('../api/src/integrationTest/resources/config/metadata-mapping.json').text
      }
      println 'Index created and mapped'
    }
  }
}